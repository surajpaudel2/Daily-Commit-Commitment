1. You call the store ‚Üí "Send me package #12345"
2. Delivery guy leaves package at your door
3. üö® PROBLEM: Your neighbor steals the package and claims it's theirs
   (They just need the tracking number #12345)

   1. You generate a SECRET_CODE at home
   2. You call the store ‚Üí "Send package #12345, but ONLY give it to someone
      who can prove they have the SECRET_CODE that matches this HASH"
   3. Delivery guy brings package but asks: "What's the secret code?"
   4. You provide the SECRET_CODE ‚Üí Package delivered safely
   5. üéØ Your neighbor can't steal it because they don't have your SECRET_CODE


   // React Frontend (http://localhost:3000)
   function LoginButton() {
     const handleLogin = () => {
       // User clicks login
       // React redirects to Spring Boot's OAuth2 endpoint
       window.location.href = 'http://localhost:8080/oauth2/authorization/keycloak';
     };

     return <button onClick={handleLogin}>Login with Keycloak</button>;
   }
   ```

   **What happens:**
   - Browser navigates to Spring Boot backend
   - No tokens yet, no authentication yet
   - This is just a navigation to trigger the OAuth flow

   ---

   ### **STEP 2: Spring Security Generates PKCE Values**
   ```
   Browser hits: http://localhost:8080/oauth2/authorization/keycloak

   Spring Security (OAuth2AuthorizationRequestRedirectFilter):
   1. Generates random string: code_verifier = "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"
   2. Computes SHA-256 hash: code_challenge = sha256(code_verifier)
      Result: "E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM"
   3. Stores code_verifier in HTTP Session (server-side memory)
   4. Generates random state value for CSRF protection
   ```

   // coming back here

   **Server Memory Now Contains:**
   ```
   Session ID: JSESSIONID=8F3A2B1C...
     ‚îú‚îÄ code_verifier: "dBjftJeZ4CVP...XEjXk"  (SECRET - kept on server)
     ‚îú‚îÄ code_challenge: "E9Melhoa2Owv...w-cM"  (will be sent to Keycloak)
     ‚îú‚îÄ state: "random-csrf-state-12345"
     ‚îî‚îÄ redirect_uri: "http://localhost:8080/login/oauth2/code/keycloak"
   ```

   ---

   ### **STEP 3: Spring Security Redirects Browser to Keycloak**
   ```
   Spring Security sends 302 Redirect response to browser:

   HTTP/1.1 302 Found
   Location: http://localhost:8180/realms/master/protocol/openid-connect/auth?
     response_type=code
     &client_id=my-spring-app
     &scope=openid profile email
     &state=random-csrf-state-12345
     &redirect_uri=http://localhost:8080/login/oauth2/code/keycloak
     &code_challenge=E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM
     &code_challenge_method=S256

   Set-Cookie: JSESSIONID=8F3A2B1C...; HttpOnly; Secure
   ```

   **What's being sent:**
   - `code_challenge`: The SHA-256 hash (NOT the secret)
   - `code_challenge_method`: "S256" means "I used SHA-256 hashing"
   - `state`: CSRF token to prevent attack
   - `redirect_uri`: Where Keycloak should send the user back

   **Browser now navigates to Keycloak's login page**

   ---

   ### **STEP 4: Keycloak Stores code_challenge**
   ```
   Keycloak receives the request and stores:

   Authorization Request Record:
     ‚îú‚îÄ client_id: "my-spring-app"
     ‚îú‚îÄ code_challenge: "E9Melhoa2Owv...w-cM"  ‚úÖ STORED
     ‚îú‚îÄ code_challenge_method: "S256"
     ‚îú‚îÄ redirect_uri: "http://localhost:8080/login/oauth2/code/keycloak"
     ‚îú‚îÄ state: "random-csrf-state-12345"
     ‚îî‚îÄ scope: "openid profile email"

   Keycloak then shows login form to user
   ```

   ---

   ### **STEP 5: User Enters Credentials in Keycloak**
   ```
   User sees Keycloak login page at:
   http://localhost:8180/realms/master/protocol/openid-connect/auth?...

   User enters:
     Username: suraj
     Password: ********

   User clicks "Sign In"
   ```

   **What happens:**
   - Browser POSTs credentials to Keycloak
   - Keycloak validates username/password against its user database
   - If valid, Keycloak creates an authenticated session

   ---

   ### **STEP 6: Keycloak Generates Authorization Code**
   ```
   After successful authentication, Keycloak:

   1. Generates authorization code: "SplxlOBeZQQYbYS6WxSbIA"
   2. Links this code to the stored code_challenge
   3. Stores mapping:

      Authorization Code Record:
        ‚îú‚îÄ code: "SplxlOBeZQQYbYS6WxSbIA"
        ‚îú‚îÄ associated_code_challenge: "E9Melhoa2Owv...w-cM"  ‚úÖ LINKED
        ‚îú‚îÄ user: "suraj"
        ‚îú‚îÄ expires_in: 60 seconds
        ‚îî‚îÄ single_use: true (can only be used once)
   ```

   ---

   ### **STEP 7: Keycloak Redirects Browser Back to Spring Boot**
   ```
   Keycloak sends 302 Redirect:

   HTTP/1.1 302 Found
   Location: http://localhost:8080/login/oauth2/code/keycloak?
     code=SplxlOBeZQQYbYS6WxSbIA
     &state=random-csrf-state-12345

   Browser follows redirect back to Spring Boot
   ```

   **Important:**
   - The authorization code is in the URL (can be intercepted)
   - BUT: It's useless without the `code_verifier` (which is still in Spring's session)

   ---

   ### **STEP 8: Spring Security Validates State & Retrieves code_verifier**
   ```
   Browser hits: http://localhost:8080/login/oauth2/code/keycloak?code=SplxlO...&state=random-csrf-state-12345

   Spring Security (OAuth2LoginAuthenticationFilter):

   1. Extracts code from URL: "SplxlOBeZQQYbYS6WxSbIA"
   2. Extracts state from URL: "random-csrf-state-12345"
   3. Looks up session using JSESSIONID cookie
   4. Validates state matches stored state (CSRF protection)
   5. Retrieves code_verifier from session: "dBjftJeZ4CVP...XEjXk"
   ```

   **Server Memory Lookup:**
   ```
   Session ID: JSESSIONID=8F3A2B1C...
     ‚îî‚îÄ code_verifier: "dBjftJeZ4CVP...XEjXk"  ‚Üê RETRIEVED FROM MEMORY
   ```

   ---

   ### **STEP 9: Spring Security Exchanges Code for Tokens (with PKCE Proof)**
   ```
   Spring Security makes backend HTTP request to Keycloak:

   POST http://localhost:8180/realms/master/protocol/openid-connect/token
   Content-Type: application/x-www-form-urlencoded

   Body:
     grant_type=authorization_code
     &code=SplxlOBeZQQYbYS6WxSbIA
     &redirect_uri=http://localhost:8080/login/oauth2/code/keycloak
     &code_verifier=dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk  ‚Üê SECRET REVEALED
     &client_id=my-spring-app
   ```

   **Critical:** This is a server-to-server call, not visible to the browser

   ---

   ### **STEP 10: Keycloak Validates code_verifier (PKCE Verification)**
   ```
   Keycloak receives the token request:

   1. Looks up authorization code: "SplxlOBeZQQYbYS6WxSbIA"
   2. Retrieves associated code_challenge: "E9Melhoa2Owv...w-cM"
   3. Hashes the received code_verifier:

      received_code_verifier = "dBjftJeZ4CVP...XEjXk"
      computed_hash = sha256(received_code_verifier)

   4. Compares:
      computed_hash == stored_code_challenge?
      "E9Melhoa2Owv...w-cM" == "E9Melhoa2Owv...w-cM"  ‚úÖ MATCH!

   5. If match ‚Üí Proceed to issue tokens
      If no match ‚Üí Reject with error: "invalid_grant"
   ```

   **This is the PKCE validation step - proving the requester is the original client**

   ---

   ### **STEP 11: Keycloak Issues Tokens**
   ```
   Keycloak validation passed, returns tokens:

   HTTP/1.1 200 OK
   Content-Type: application/json

   {
     "access_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjEyMyJ9.eyJzdWIiOiJzdXJhaiIsImlzcyI6Imh0dHA6Ly9sb2NhbGhvc3Q6ODE4MC9yZWFsbXMvbWFzdGVyIiwiZXhwIjoxNzM5MjI3MjAwLCJpYXQiOjE3MzkyMjY5MDAsInJlYWxtX2FjY2VzcyI6eyJyb2xlcyI6WyJhZG1pbiIsInVzZXIiXX19.signature",

     "id_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJzdXJhaiIsImVtYWlsIjoic3VyYWpAZXhhbXBsZS5jb20iLCJuYW1lIjoiU3VyYWoifQ.signature",

     "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJzdXJhaiIsImV4cCI6MTczOTMxMzMwMH0.signature",

     "token_type": "Bearer",
     "expires_in": 300,
     "refresh_expires_in": 86400,
     "scope": "openid profile email"
   }
   ```

   **Token Contents:**
   - **access_token**: Used for API calls (contains roles/permissions)
   - **id_token**: User identity information (name, email)
   - **refresh_token**: Used to get new access tokens when they expire

   ---

   ### **STEP 12: Spring Security Stores Tokens & Creates Authentication**
   ```
   Spring Security receives the tokens:

   1. Validates JWT signatures using Keycloak's public key
   2. Parses JWT claims (user info, roles, expiry)
   3. Creates Authentication object:

      OAuth2AuthenticationToken:
        ‚îú‚îÄ principal: "suraj"
        ‚îú‚îÄ authorities: [ROLE_admin, ROLE_user]
        ‚îú‚îÄ authenticated: true
        ‚îî‚îÄ credentials: [access_token, id_token, refresh_token]

   4. Stores in SecurityContext (server-side session):

      Session ID: JSESSIONID=8F3A2B1C...
        ‚îî‚îÄ SPRING_SECURITY_CONTEXT:
             ‚îî‚îÄ authentication: OAuth2AuthenticationToken (above)

   5. Clears code_verifier from session (no longer needed)
   ```

   ---

   ### **STEP 13: Spring Boot Redirects Browser to React App**
   ```
   Spring Security sends final redirect:

   HTTP/1.1 302 Found
   Location: http://localhost:3000/dashboard
   Set-Cookie: JSESSIONID=8F3A2B1C...; HttpOnly; Secure; SameSite=Lax

   Browser navigates back to React app